import warnings
from lys import filters
from lys.errors import NotImplementedWarning

from LysQt.QtCore import pyqtSignal
from .SaveCanvas import CanvasPart, saveCanvas


class WaveData(CanvasPart):
    """
    Interface to access wave data in the canvas.

    This class is inherited by :class:`.Line.LineData`, :class:`.Image.ImageData`, :class:`.RGB.RGBData`,  :class:`.Vector.VectorData`, and :class:`.Contour.ContourData`.

    Instance of WaveData is automatically generated by display or append methods.

    """
    modified = pyqtSignal()
    """This pyqtSignal is emimtted when the data is changed."""

    def __init__(self, canvas, wave, axis):
        super().__init__(canvas)
        self.wave = wave
        self.wave.modified.connect(self._update)
        self.axis = axis
        self.appearance = {}
        self.offset = (0, 0, 0, 0)
        self.filter = None
        self.filteredWave = wave
        self._z = 'default'

    def __del__(self):
        self.wave.modified.disconnect(self._update)

    @saveCanvas
    def _update(self, *args, **kwargs):
        self.filteredWave = self._filteredWave(self.wave, self.offset, self.filter)
        self._updateData()
        self.modified.emit()

    def _filteredWave(self, w, offset, filter):
        if filter is None:
            filt = filters.Filters([filters.OffsetFilter(offset)])
        else:
            filt = filter + filters.OffsetFilter(offset)
        return filt.execute(w)

    @saveCanvas
    def setVisible(self, visible):
        """
        Set the visibility of the data.

        Args:
            visible(bool): The visibility of the data.
        """
        self._setVisible(visible)
        self.appearance['Visible'] = visible

    def getVisible(self):
        """
        Get the visibility of the data.

        Return:
            bool: The visibility of the data.
        """
        return self.appearance.get('Visible', True)

    @saveCanvas
    def setOffset(self, offset):
        """
        Set the offset to the data.

        The data is offset as x'=x*x1+x0 and y'=y*y1+y0.

        Args:
            offset(tuple of length 4 float): The offset in the form of (x0, y0, x1, y1). 
        """
        self.offset = offset
        self._update()

    def getOffset(self):
        """
        Get the offset to the data.

        See :meth:`setOffset` for detail.

        Return:
            tuple of length 4 float: The offset in the form of (x0, y0, x1, y1). 
        """
        return self.offset

    @saveCanvas
    def setFilter(self, filter=None):
        """
        Apply filter to the data.

        Args:
            filter(filterr): The filter. See :class:`lys.filters.filter.FilterInterface.FilterInterface` 
        """
        self.filter = filter
        self._update()

    def getFilter(self):
        return self.filter

    @saveCanvas
    def setZOrder(self, z):
        """
        Set the z order of the data.

        Args:
            z(int): The z order. 
        """
        self._setZ(z)
        self._z = z

    def getZOrder(self):
        """
        Get the z order of the data.

        Return:
            int: The z order. 
        """
        return self._z

    def saveAppearance(self):
        """
        Save appearance from dictionary.

        Users can save/load appearance of data by save/loadAppearance methods.

        Return:
            dict: dictionary that include all appearance information.
        """
        return dict(self.appearance)

    @saveCanvas
    def loadAppearance(self, appearance):
        """
        Load appearance from dictionary.

        Users can save/load appearance of data by save/loadAppearance methods.

        Args:
            appearance(dict): dictionary that include all appearance information, which is usually generated by :meth:`saveAppearance` method.
        """
        self.setVisible(appearance.get('Visible', True))
        self._loadAppearance(appearance)

    def _setVisible(self, visible):
        warnings.warn(str(type(self)) + " does not implement _setVisible(visible) method.", NotImplementedWarning)

    def _setZ(self, z):
        warnings.warn(str(type(self)) + " does not implement _setZ(z) method.", NotImplementedWarning)

    def _updateData(self):
        raise NotImplementedError(str(type(self)) + " does not implement _updateData() method.")

    def _loadAppearance(self):
        raise NotImplementedError(str(type(self)) + " does not implement _loadAppearance(appearance) method.")
